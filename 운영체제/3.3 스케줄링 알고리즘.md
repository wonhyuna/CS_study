# 스케줄링 알고리즘
- **CPU 스케줄러** (단기 스케줄러)가 준비 큐에 있는 프로세스 중 어떤 프로세스를 실행시킬지 결정하는 데 사용

### 스케줄링 기준
- CPU 사용률: CPU를 놀리지 않고 사용하는지 판단
- 처리량: 단위 시간당 실행한 프로세스 수
- 응답 시간: 프로세스에 요청이 발생했을 때 응답까지 걸리는 시간
- 반환 시간: 프로세스가 로드된 이후부터 종료될 때까지 걸리는 시간
- 대기 시간: 프로세스가 대기 큐에서 대기하는 시간의 총합

### 스케줄링 종류
#### 비선점형 스케줄링
- 실행 중인 프로세스가 종료될 때까지 다른 프로세스를 실행할 수 없음
- **FCFS**: 준비 큐에 먼저 들어온 프로세스가 우선순위를 갖는 알고리즘 (선입선출)
- **SJF(SJN)**: 실행 시간이 짧은 프로세스가 우선순위를 갖는 알고리즘
  - 준비 큐에 있는 프로세스 중 CPU를 점유하는 실행 시간이 가장 짧은 프로세스부터 실행
  - 평균 대기 시간이 가장 짧지만, 실행 시간이 긴 프로세스는 실행 시간이 짧은 프로세스에 밀려 기아 상태가 됨


#### 선점형 스케줄링
- 스케줄러가 실행 중인 프로세스를 중단시키고 다른 프로세스를 실행할 수 있음
- **RR**: 프로세스 간 우선순위 X, 모든 프로세스를 **순서대로 일정 시간** 동안 실행하며, 초과 시 다른 프로그램 실행
  - 일정시간: 시간 단위 (타임 퀀텀, 타임 슬라이스) (10~100밀리초)
  - 콘텍스트 스위칭이 빈번히 일어나 오버헤드가 크지만 모든 프로세스가 반복 수행되어 응단 속도가 빠름
- **SRTF**: 준비 큐에서 대기 시간이 가장 짧게 남은 프로세스를 우선 수행하는 알고리즘
  - 한 프로세스가 실행 중일 때 실행 시간이 더 짧은 프로세스가 준비 큐에 들어오면 **실행 시간이 더 짧은 프로세스**가 CPU 차지
  - 평균 대기 시간이 짧지만 수행 시간이 긴 프로세스는 기아 상태가 되기 쉬움
- **멀티 레벨**: 준비 큐를 목적에 따라 **여러 개로 분리**해 사용하는 알고리즘
  - 분리한 큐는 각각 우선순위가 있고 각자 다른 스케줄링 알고리즘을 적용함
  - 여러 개의 큐는 foreground 큐와 background 큐로 나뉨
  - *foreground 큐* 에는 **응답 속도**가 중요한 프로세스가 들어가고, *background 큐* 에는 응답 속도보다 **성능**을 중요시하는 프로세스가 들어감


#### 스케줄링 예제
|프로세스 이름|예상 실행 시간|준비 큐에 들어온 시간|
|-----|-----|-----|
|P1|150|0|
|P2|60|20|
|P3|300|40|
|P4|270|60|
|P5|120|80|

- FCFS
  - P1(150) -> P2(60) -> P3(300) -> P4(270) -> P5(120)
  - 평균 대기 시간
    (0+(150-20)+(210-40)+(510-60)+(780-80)) / 5 = 290

- SJF
  - P1(150) -> P2(60) -> P5(120) -> P4(270) -> P3(300)
  - 평균 대기 시간
    (0+(150-20)+(600-40)+(330-60)+(210-80)) / 5 = 218

- RR
  - 계속 50씩 P1 ~ P5까지 돌고 50 이하로 남았을 땐 남은 만큼만 하고 다음으로 넘어감
  - 평균 대기 시간: 최대 시간 (전체 프로세스 수 - 1)*시간단위
    (5-1)*50 = 200 밀리초

- SRTF
  - P1(20) -> P2(60) -> P5(120) -> P1(130) -> P4(270) -> P3(300)
  - 평균 대기 시간
    ((200-20) + (20-20) + (600-40) + (330-60) + (80-80)) / 5 = 202

- 멀티 레벨 스케줄링
  - 여러 큐로 나눔
  - 시스템 작업 큐 / 대화형 작업 큐 / 대화형 편집 작업 큐 / 일괄처리형 작업 큐 / 학생 작업 큐